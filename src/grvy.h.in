// -*-c++-*-
//-----------------------------------------------------------------------bl-
//--------------------------------------------------------------------------
// 
// libGRVY - a utility library for scientific computing.
//
// Copyright (C) 2008,2009,2010,2011 The PECOS Development Team
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the Version 2.1 GNU Lesser General
// Public License as published by the Free Software Foundation.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc. 51 Franklin Street, Fifth Floor, 
// Boston, MA  02110-1301  USA
//
//-----------------------------------------------------------------------el-
//
// grvy.h: Basic API Definitions
//
// $Id$
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------

#include<stddef.h>

#ifndef GRVY_H_
#define GRVY_H_

/** \file 
 *
 * This section outlines the available GRVY functions for C/C++.  To
 * access, make sure to \#include <grvy.h> within your source code
 * files. Several simple examples using these functions are provided
 * in the examples section.  Unless specified otherwise, functions
 * which have an integer return value return "0" upon success (and the
 * primary excepton to this rule is with a subset of the Input Parsing
 * routines).  To illustrate the organizational flexibility of the
 * input file parsing, a \ref inputFile "sample input file" is also
 * provided.  <hr>
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

/** \cond */

/* Library version/build information */

#define GRVY_MAJOR_VERSION  @GENERIC_MAJOR_VERSION@
#define GRVY_MINOR_VERSION  @GENERIC_MINOR_VERSION@
#define GRVY_MICRO_VERSION  @GENERIC_MICRO_VERSION@

#define GRVY_BUILD_USER     "@BUILD_USER@"
#define GRVY_BUILD_ARCH     "@BUILD_ARCH@"
#define GRVY_BUILD_HOST     "@BUILD_HOST@"
#define GRVY_BUILD_DATE     "@BUILD_DATE@"
#define GRVY_BUILD_VERSION  "@BUILD_VERSION@"

#define GRVY_LIB_VERSION    "@VERSION@"
#define GRVY_LIB_RELEASE    "@BUILD_DEVSTATUS@"

#define GRVY_CXX            "@CXX@"
#define GRVY_CXXFLAGS       "@CXXFLAGS@"

#define GRVY_FC             "@FC@"
#define GRVY_FCFLAGS        "@FCFLAGS@"

/** \endcond */

  /* \page apiC C/C++ Library Interface
   *
   * This section outlines the available GRVY functions for C/C++.  To
   * use, make sure to \#include <grvy.h> within your source code
   * files. Several simple examples using these functions are provided
   * in the examples section.  Unless specified otherwise, functions
   * which have an integer return value return "0" upon success (and
   * the primary excepton to this rule is with a subset of the Input
   * Parsing routines).
   * 
   * To illustrate the organizational flexibility
   * of the input file parsing, a \ref inputFile "sample input file"
   * is also provided.  <hr>
   * 
   * \section version Versioning Routines
   *
   */

  /**
   * \page apiC
   * \code
   * void grvy_version_stdout           ();
   *  int grvy_get_numeric_version      ();
   * \endcode
   */

  /** @defgroup Capi C API
   *
   * \brief This page provides a link to all of the C style functions which
   * are available in libGRVY (organized by functionality). To access
   * these routines from C/C++, make sure to \#include <grvy.h> within
   * your source code files. Unless specified otherwise, functions
   * which have an integer return value return "0" upon success (and
   * the primary excepton to this rule is with a subset of the Input
   * Parsing routines).
   *
   * Click on one of the boxes to see more details on the routines
   * available for each utility. Alternatively, if you prefer to see
   * all of the routines as part of the C API on a single page, refer to the
   * header file, grvy.h directly.
   * 
   * <hr>
   */

  /** @defgroup Cversioning Runtime Versioning Information
   *  @ingroup Capi
   * 
   *  \brief Obtain libGRVY runtime versioning information.
   *
   */

  /* \ingroup Cversioning
   * \name Versioning Routines:
   * 
   */

  /** \ingroup Cversioning
   *  \name Versioning Routines:
   *
   *  Obtain libGRVY runtime versioning information.
   *
   */

  /** \ingroup Cversioning
   *  \brief Echo library versioning information to stdout
   */

  extern void grvy_version_stdout           ();

  /** \ingroup Cversioning
   *  \brief Obtain numeric library version 
   *  \return running version
   */

  extern int grvy_get_numeric_version       ();

  /* @} */  

  /*
   * \page apiC
   * \section input Input Parsing
   * 
   * These routines are used to parse input values keyword/value pairs 
   */

  /** \defgroup Cinput Input Parsing
   *
   * @ingroup Capi
   *
   * \brief Routines for accessing input parameters from a libGRVY style
   * input file. Note that an input file must be open prior to reading
   * any keyword/value pairs or performing input file dump operations.
   *
   */

  /** \ingroup Cinput
   * \name Input Parsing - File open/close:
   *
   * Routines for accessing input parameters from a libGRVY style
   * input file. Note that an input file must be open prior to reading
   * any keyword/value pairs or performing input file dump operations.
   *
   */

  /** \ingroup Cinput
   * \brief Open a libGRVY style input file
   * \param filename desired input filename
   */

  extern int grvy_input_fopen               (const char *filename);

  /** \ingroup Cinput
   *  \brief Close the currently open libGRVY style input file */

  extern int grvy_input_fclose              ();

  /** \ingroup Cinput
   *  \name Input Parsing - Dump input file contents:
   * 
   * The following routines can be used to dump the entire contents of
   * a parsed libGRVY style input file to stdout or to an ASCII file
   * (note that all comments within the original input file are
   * stripped). The prefix variable can be used to include an
   * additional delimiter which prepends each line of the output. Note
   * that an input file must be open prior to reading any performing
   * input file dump operations. These routines are normally used to
   * save all relevant input parameters in the application output for
   * future traceability and repeatability.
   *
   */

  /** \ingroup Cinput
   * @{
   */

  /** \brief Dump input file settings to stdout. */

  extern int grvy_input_fdump               ();

  /** \brief Dump input file settings to stdout prefixed by a delimiter */

  extern int grvy_input_fdump_delim         (const char* prefix);

  /** \brief Dump input file settings to an open file with a provided prefix delimiter 
   */

  extern int grvy_input_fdump_file          (const char* prefix, const char *filename);

  /** @} */

  /** \ingroup Cinput
   *  \name Input Parsing - Read scalar values:
   *
   * The following routines are used to read individual input values
   * for common intrinsic datatypes given a desired keyword character
   * string (keyword).  All grvy_input_fread_() routines return 1 on sucess and 0
   * on failure.  This return behavior is intended as a convenience
   * for applications to check input file parsing errors over consecutive reads
   * via multiplicative operations. 
   * 
   */


  /** \ingroup Cinput
   * @{
   */

   /** \brief Read a single input integer \e value corresponding to the \e keyword path
    *  \param keyword input keyword path
    *  \param corresponding value in input file
    */

   extern int grvy_input_fread_int           (const char* keyword, int *value);

   /** \brief Read a single input float \e value corresponding to the \e keyword path
    *  \param keyword input keyword path
    *  \param corresponding value in input file
    */

   extern int grvy_input_fread_float         (const char* keyword, float *value);

   /** \brief Read a single input double \e value corresponding to the \e keyword path
    *  \param keyword input keyword path
    *  \param corresponding value in input file
    */

   extern int grvy_input_fread_double        (const char* keyword, double *value);

   /** \brief Read a single input character string \e value corresponding to the \e keyword path
    *  \param keyword input keyword path
    *  \param corresponding value in input file
    */

   extern int grvy_input_fread_char          (const char* keyword, char **value);

  /** @} */

  /** \ingroup Cinput
   *  \name Input Parsing (Read vector values):
   *
   * The following routines are used to read vector valued input values
   * for common intrinsic datatypes given a desired keyword character
   * string (keyword).  
   */

  /** \ingroup Cinput
   * @{
   */

  extern int grvy_input_fread_int_vec       (const char* keyword, int *value,    int nelems);
  extern int grvy_input_fread_float_vec     (const char* keyword, float *value,  int nelems);
  extern int grvy_input_fread_double_vec    (const char* keyword, double *value, int nelems);
  extern int grvy_input_fread_char_ivec     (const char* keyword, char **value,  int elem);

  /** @} */  

  /** \ingroup Cinput
   *  \name Input Parsing (Read ith vector values):
   *
   * The following routines are used to read the ith entry (entry) of
   * vector valued input values for common intrinsic datatypes given a
   * desired keyword character string (keyword).  
   */

  /** \ingroup Cinput
   * @{
   */

  extern int grvy_input_fread_int_ivec      (const char* keyword, int *value,    int elem);
  extern int grvy_input_fread_float_ivec    (const char* keyword, float *value,  int elem);
  extern int grvy_input_fread_double_ivec   (const char* keyword, double *value, int elem);

  /** @} */

  /** \ingroup Cinput 
   *  \name Default Value Registration Functions:
   *
   * The following routines provide a mechanism to register a default
   * value with the input parsing mechanism. If a particular keyword
   * (var) has a registered default value and is subsequently queried
   * with an input file which does not contain the keyword, the
   * registered default value will be returned instead. A convenient
   * use for these registration functions is to provide sensible
   * defaults to newly added input keywords which are not present in
   * older input file revisions.
   */

  /** \ingroup Cinput
   * @{
   */

  /* Input variable registration functions (to provide default input
     values and backwards compatibility support) */

  /* Register default integer value */

  extern int grvy_input_register_int        (const char *var,     int value);

  /* Register default float value */

  extern int grvy_input_register_float      (const char *var,   float value);
  extern int grvy_input_register_double     (const char *var,  double value);
  extern int grvy_input_register_char       (const char *var,   char *value);

  extern int grvy_input_register_get_int    (const char *var,    int *value);
  extern int grvy_input_register_get_float  (const char *var,  float *value);
  extern int grvy_input_register_get_double (const char *var, double *value);
  extern int grvy_input_register_get_char   (const char *var,  char **value);

  /** @} */


  /** \defgroup Ctimer Performance Timer Utilities 
   *  \ingroup Capi
   *
   * \brief Routines for measuring runtime performance of specific
   * (nested) code sections for performance analysis, statistical
   * analysis, and historical runtime logging.
   */

  /* \ingroup Ctimer
   * \name Performance Timer Functions 
   * 
   * \brief Routines for 
   */

  /** \ingroup Ctimer
   * @{
   */

  /** Basic wallclock timer
   * \return time since epoch in seconds
   */

  extern double grvy_timer                     ();
  extern   void grvy_timer_init                (const char *id);
  extern   void grvy_timer_reset               ();
  extern   void grvy_timer_finalize            ();
  extern   void grvy_timer_begin               (const char *id);
  extern   void grvy_timer_end                 (const char *id);
  extern double grvy_timer_elapsedseconds      (const char *id);
  extern double grvy_timer_elapsed_global      ();
  extern    int grvy_timer_stats_count         (const char *id);
  extern double grvy_timer_stats_mean          (const char *id);
  extern double grvy_timer_stats_variance      (const char *id);
  extern   void grvy_timer_summarize           ();
  extern    int grvy_timer_set_summarize_width (const int maxwidth);

  /** @} */

  // ------------------------------------------------------------------------
  // Historical timing support - note there are two primary mechanisms for
  // saving performance data: 
  // 
  // Mode 1: you are using the grvy_timer_* class of routines to
  //         define individual sections to monitor and want to save
  //         the global runtime measurement and all individually
  //         defined subtimers.
  // 
  // Mode 2: you are using other means to profile the application code
  //         and want to save a single global timing value. Routines
  //         for this mode are distinguished by the presence of an
  //         extra "timing" argument in the calling sequence.
  // 
  // In both modes, standard and expanded (exp) calling sequences are supported
  // with the expanded version allowing additional optional runtime
  // documentation (e.g. flops, code revision) to be provided.
  // ------------------------------------------------------------------------

  // Mode 1: Saving internal GRVY timer values to historical repository

  extern    int grvy_timer_save_hist         (const char*experiment, const char *comment, 
					      int num_procs, const char *filename);
						
  extern    int grvy_timer_save_hist_exp     (const char*experiment, const char *comment, 
					      int num_procs, int jobId, const char *code_revision, double flops,
					      const char *filename);

  // Mode 2: Saving external user-provided global timing to historical repository

  extern    int grvy_timer_save_hist_ext     (double timing, const char *machinename,const char*experiment, 
					      const char *comment,const char *filename);
					      
  extern    int grvy_timer_save_hist_ext_exp (double timing, const char *machinename, const char*experiment, 
					      const char *comment, int num_procs, int jobId, 
					      const char *code_revision, double flops, const char *filename);

  // Summarize and dump historical timing information to ascii files

  void grvy_summarize_hist_timing            (const char *filename, const char *delimiter, const char *outdir);

  // ----------------------------------------------------------------
  // ----------------------------------------------------------------

  /** \defgroup Cocore MPI Out-of-Core Utilities 
   *  \ingroup Capi
   *
   * \brief Routines to offload out-of-core read/write operations to a
   * pool of distributed shared-memory nodes using MPI for data
   * transfer.  An additional level of indirection can be enabled to
   * offload less-frequently accessed data to one or more disk-based files.
   */

  /** \ingroup Cocore 
   * @{ 
   */
      
  extern    int grvy_ocore_init                (const char *input_file);
  extern   void grvy_ocore_finalize            ();

  extern    int grvy_ocore_master              ();
  extern    int grvy_ocore_enabled             ();
  extern size_t grvy_ocore_num_active          ();

  /** @}
   *
   * \ingroup Cocore 
   * \name Read/Write Routines 
   *
   */

  /** \ingroup Cocore
   * @{
   */

  extern    int grvy_ocore_write_double        (size_t record_id,    double     *data);
  extern    int grvy_ocore_write_float         (size_t record_id,     float     *data);
  extern    int grvy_ocore_write_int           (size_t record_id,       int     *data);
  extern    int grvy_ocore_write_long_long_int (size_t record_id, long long int *data);

  extern    int grvy_ocore_read_double         (size_t record_id,    double     *data);
  extern    int grvy_ocore_read_float          (size_t record_id,     float     *data);
  extern    int grvy_ocore_read_int            (size_t record_id,       int     *data);
  extern    int grvy_ocore_read_long_long_int  (size_t record_id, long long int *data);

  /** @}
   * \ingroup Cocore
   * \name Record retreival 
   */

  /** \ingroup Cocore
   * @{ */

  extern size_t grvy_ocore_pop_record_float         (        float *data);
  extern size_t grvy_ocore_pop_record_double        (       double *data);
  extern size_t grvy_ocore_pop_record_int           (          int *data);
  extern size_t grvy_ocore_pop_record_long_long_int (long long int *data);

  /** @} */
					      
  /*
   * Basic API Definition for Math Utilities
   */

  /** 
   * \defgroup Cmath Floating-Point Utilities 
   * \ingroup  Capi
   * 
   * \brief Routines for detecting floating-point errors.
   */

  /** \ingroup Cmath
   * @{ */

  extern int grvy_double_isnan            (double *val);
  extern int grvy_double_isinf            (double *val);

  extern int grvy_float_isnan             (float  *val);
  extern int grvy_float_isinf             (float  *val);

  /* @} */

  /*
   * Logging Utilities
   */

  /* Available logging priorities; roughly mimics syslog priority levels but with
   * fewer options. Also provides a NOLOG option to disable all log messages. 
   */

  /** \cond */
  
  typedef enum {GRVY_NOLOG  =  -1,
		GRVY_FATAL  =   0,
		GRVY_ERROR  = 100,
		GRVY_WARN   = 200,
		GRVY_INFO   = 300,
		GRVY_DEBUG  = 400,
		GRVY_ALL    = 500
  } PriorityLevel;

  /** \endcond */

  /**
   * \defgroup Clog Logging Utilities
   * \ingroup Capi
   *
   * \brief The following routines provide a priority-based logging
   * mechanism to control application messages. A set of default
   * priority definitions are provided to define messages of the
   * following form:
   *
   * - GRVY_FATAL
   * - GRVY_ERROR
   * - GRVY_WARN 
   * - GRVY_INFO 
   * - GRVY_DEBUG
   *
   */

  /** \ingroup Clog
   * @{ */

  extern void grvy_log_setlevel           (int priority);
  extern int  grvy_log_getlevel           ();
  extern void grvy_log_setmask            (int loglevel, const char *delimiter);
  extern void grvy_log                    (int loglevel, const char *mesg);
  extern  int grvy_printf                 (int loglevel, const char *format,...);
  extern void grvy_log_int                (int loglevel, const char *func, const char *mesg, int var);
  extern void grvy_log_float              (int loglevel, const char *func, const char *mesg, float var);
  extern void grvy_log_double             (int loglevel, const char *func, const char *mesg, double var);
  extern void grvy_log_char               (int loglevel, const char *func, const char *mesg, const char *char_item);

  /** @} */

  /** 
   * \defgroup Cmisc Miscellaneous File Path Utilities
   * \ingroup Capi
   * 
   * \brief I/O utilities for file path interaction.
   */

  /** \ingroup Cmisc
   * @{ */

  extern int  grvy_check_file_path        (const char *pathname);
  extern int  grvy_create_unique_dir      (      char *name_template);
  extern int  grvy_create_scratch_dir     (      char *name_template);

  /** @} */

  /*
   * Doxygen API Definitions
   */

  /*! \page apiC
   * \section input Input Parsing Routines
   *
   * <b>Open/close a libGRVY style input file:</b>
   * \code
   * int grvy_input_fopen               (const char *filename);
   * int grvy_input_fclose              ();
   * \endcode
   *
   * <b> Dump the contents of a libGRVY style input file :</b>
   * 
   * The following routines can be used to dump the entire contents of
   * a parsed libGRVY style input file to \e stdout or to an ASCII
   * file (note that all comments within the original input file are
   * stripped). The prefix variable can be used to include an
   * additional delimiter which prepends each line of the output.
   * These routines are normally used to save all relevant input
   * parameters in the application output for future traceability and
   * repeatability.
   *
   * \code
   * int grvy_input_fdump               ();
   * int grvy_input_fdump_delim         (const char* prefix);
   * int grvy_input_fdump_file          (const char* prefix, const char *filename);
   * \endcode
   *
   * <b>Read a single int, float, double, or char string for input keyword \e var:</b>
   * \code
   * int grvy_input_fread_int           (const char* var, int    *value);
   * int grvy_input_fread_float         (const char* var, float  *value);
   * int grvy_input_fread_double        (const char* var, double *value);
   * int grvy_input_fread_char          (const char* var, char  **value);
   * \endcode
   *
   * <b>Read a vector of ints, floats, or doubles for input keyword \e var:</b>
   * \code
   * int grvy_input_fread_int_vec       (const char* var, int    *value, int nelems);
   * int grvy_input_fread_float_vec     (const char* var, float  *value, int nelems);
   * int grvy_input_fread_double_vec    (const char* var, double *value, int nelems);
   * \endcode
   *
   * <b>Read the \e ith entry (elem) of a vector of ints, floats,
   * doubles, or characters for input keyword \e var:</b>
   *
   * \code
   * int grvy_input_fread_int_ivec      (const char* var, int *value,    int elem);
   * int grvy_input_fread_float_ivec    (const char *var, float *value,  int elem);
   * int grvy_input_fread_double_ivec   (const char* var, double *value, int elem);
   * int grvy_input_fread_char_ivec     (const char* var, char **value,  int elem);
   * \endcode
   *
   * <b> Support for the creation of backwards compatible input files:</b>
   *
   * The following routines provide a mechanism to register a default
   * value with the input parsing mechanism.  If a particular keyword
   * (\e var) has a registered default value and is subsequently
   * queried with an input file which does not contain the keyword, the
   * registered default value will be returned instead.  A convenient
   * use for these registration functions is to provide sensible
   * defaults to newly added input keywords which are not present in
   * older input file revisions.
   *
   * \code
   * int grvy_input_register_int        (const char *var,     int value);
   * int grvy_input_register_float      (const char *var,   float value);
   * int grvy_input_register_double     (const char *var,  double value);
   * int grvy_input_register_char       (const char *var,   char *value);
   * \endcode
   *
   * The following routines can be used to query the current hashed
   * values of any keyword variables which have been registered
   * previously.
   *
   * \code
   * int grvy_input_register_get_int    (const char *var,    int *value);
   * int grvy_input_register_get_float  (const char *var,  float *value);
   * int grvy_input_register_get_double (const char *var, double *value);
   * int grvy_input_register_get_char   (const char *var,  char **value);
   * \endcode
   *
   * \section timing Performance Timing Routines
   * \code
   * double grvy_timer                  ();
   * void   grvy_timer_init             (const char *id);
   * void   grvy_timer_reset            ();
   * void   grvy_timer_finalize         ();
   * void   grvy_timer_begin            (const char *id);
   * void   grvy_timer_end              (const char *id);
   * double grvy_timer_elapsedseconds   (const char *id);
   * double grvy_timer_elapsed_global   ();
   * void   grvy_timer_summarize        ();
   *
   *    int grvy_timer_stats_count      (const char *id);
   * double grvy_timer_stats_mean       (const char *id);
   * double grvy_timer_stats_variance   (const char *id);
   * \endcode

   * \section logging Logging Utilities
   *
   * The following routines provide a priority-based logging mechanism
   * to control application messages.  A set of default priority definitions are
   * provided to define messages of the following form:
   *
   * - GRVY_FATAL
   * - GRVY_ERROR
   * - GRVY_WARN 
   * - GRVY_INFO 
   * - GRVY_DEBUG
   *
   * The suggested usage of the logging mechanism is to use the
   * following routine to generate messages as opposed to writing to \e stdout
   * or \e stderr directly.  Note that to use, each message must also be assigned a 
   * priority loglevel (e.g. GRVY_WARN).
   *
   * \code void grvy_log                    (int loglevel, const char *mesg); \endcode
   * 
   * For finer control over log messages, a printf style logger is
   * available which follows the normal printf() variable argument
   * list calling sequence with the addition of a priority loglevel.
   *
   * \code int grvy_printf                  (int loglevel, const char *format,...); \endcode
   *
   * Additional type-specific functions are also available for
   * convenience to include intrinsic values (and a calling function
   * name) within the log message.
   *
   * \code
   * void grvy_log_int                (int loglevel, const char *func, const char *mesg, int var);
   * void grvy_log_float              (int loglevel, const char *func, const char *mesg, float var);
   * void grvy_log_double             (int loglevel, const char *func, const char *mesg, double var);
   * void grvy_log_char               (int loglevel, const char *func, const char *mesg, const char *char_item);
   * \endcode
   * 
   * The verbosity of the application output can then be controlled by
   * setting the current loglevel as desired (for example, the
   * GRVY_INFO mode would show all messages except those set to the
   * GRVY_DEBUG loglevel).  The default loglevel is set to GRVY_ERROR
   * but can be altered via the following:
   *
   * \code void grvy_log_setlevel           (int priority);\endcode
   *
   * Note that two additional default priority loglevels exist,
   * GRVY_NOLOG and GRVY_ALL which can be used to disable or enable
   * all log output, respectively.
   *
   * \section math Math Utilities
   * 
   * The following routines provide unified floating-point checks for NANs and INFs.
   *
   * \code
   * int grvy_double_isnan              (double *val);
   * int grvy_double_isinf              (double *val);
   *   				  
   * int grvy_float_isnan               (float  *val);
   * int grvy_float_isinf               (float  *val);
   * \endcode
   *
   * \section misc Miscellaneous Routines
   * <b>grvy_check_file_path:</b>
   * This routine checks a desired output \e pathname and creates any non-existing parent directories.
   * \code
   * int    grvy_check_file_path        (const char *pathname);
   * \endcode
   * <b>grvy_create_unique_dir:</b>
   *
   * This routine creates a new, unique directory with 0700 permissions using the
   * provided template name.  The last six characters of name_template
   * must be XXXXXX, and name_template is modified with the unique
   * name upon return.
   *
   * \code
   * int    grvy_create_unique_dir      (char *name_template);
   * \endcode
   *
   * <b>grvy_create_scratch_dir:</b>
   *
   * Identical to grvy_create_unique_dir(), except that the new directory and
   * all of its contents are deleted when the process exits.
   *
   * \code
   * int    grvy_create_scratch_dir     (char *name_template);
   * \endcode
   */


#ifdef __cplusplus
}

//--------------------------
// C++ GRVY Interfaces
//--------------------------

#include<vector>
#include<map>
#include<string>
#include<memory>

// Forward declare GetPot class so we don't need
// to include getpot.h here.

namespace GRVYGetPot
  {
    class GetPot;
  }

//--------------------
// Input Parsing Class
//--------------------

namespace GRVY {

  void GRVY_version_stdout();
  int  GRVY_get_numeric_version();

class GRVY_Input_Class {

 public:
  GRVY_Input_Class  ();
  void Initialize   ();
  int  VerifyInit   ();
  int  Open         (const char *filename);
  int  Close        ();
  void MsgToggle    (int flag);

  int  Fdump        ();
  int  Fdump        (const char *prefix);
  int  Fdump        (const char *prefix, const char *filename);

  // Numerical Read Functions

  template <typename T> int Read_Var      (std::string var, T *value );
  template <typename T> int Read_Var_Vec  (std::string var, T *value, int nelems);
  template <typename T> int Read_Var_iVec (std::string var, T *value, int elem);

  template <typename T> int Read_Var      (std::string var, T *value, T vardef);
  template <typename T> int Read_Var_Vec  (std::string var, T *value, int nelems, T vardef);
  template <typename T> int Read_Var_iVec (std::string var, T *value, int elem,   T vardef);

  template <typename T> int Read_Var      (const char *var, T *value );
  template <typename T> int Read_Var_Vec  (const char *var, T *value, int nelems);
  template <typename T> int Read_Var_iVec (const char *var, T *value, int elem);

  template <typename T> int Read_Var      (const char *var, T *value, T vardef);
  template <typename T> int Read_Var_Vec  (const char *var, T *value, int nelems, T vardef);
  template <typename T> int Read_Var_iVec (const char *var, T *value, int elem,   T vardef);

  // Character String Read Functions

  int Read_Var                            (const char *var, char **value);
  int Read_Var_iVec                       (const char *var, char **value, int elem);

  // String Read Functions

  int Read_Var                            (const char *var, std::string *value);
  int Read_Var                            (const char *var, std::string *value, std::string vardef);
  //  int Read_Var_iVec                       (const char *var, char **value, int elem);

  // Bool Read Functions

  int Read_Var                            (const char *var, bool *value, bool vardef);

  // Default Variable Registration Functions

  void Register_Var  (const char *varname, int     var);
  void Register_Var  (const char *varname, float   var);
  void Register_Var  (const char *varname, double  var);
  void Register_Var  (const char *varname, bool    var);
  void Register_Var  (const char *varname, const char  *var);
  void Register_Var  (const char *varname, std::string  var);

  int  Get_Var       (const char *varname, int    *var);
  int  Get_Var       (const char *varname, float  *var);
  int  Get_Var       (const char *varname, double *var);
  int  Get_Var       (const char *varname, char  **var);
  int  Get_Var       (const char *varname, std::string *var);

  void PrintRegVars  (const char *prefix);

 private:
  GRVYGetPot::GetPot* ifile;          // input file
  short int           initialized;    // input file initialized?

  // Registry Maps

  std::map<std::string, int         > default_ints;
  std::map<std::string, float       > default_floats;
  std::map<std::string, double      > default_doubles;
  std::map<std::string, bool        > default_bools;
  std::map<std::string, std::string > default_strings;

  // GetPot Defaults

  float  Float_Def;
  double Double_Def;
  int    Int_Def;
  long   Long_Def;
  std::string String_Def;
  const char  *Char_Def;
  const char  *comment_start;
  const char  *comment_end;

  template <typename T> T Get_Default   (T);
};

//--------------------------
// Performance Timing Class
//--------------------------

class GRVY_Timer_Class {

 public:
  GRVY_Timer_Class        (); 
 ~GRVY_Timer_Class        ();

  void   Init             (std::string name); // intialize global timing process
  void   BeginTimer       (std::string id);   // starts local timer
  void   EndTimer         (std::string id);   // ends local timer
  void   Finalize         ();                 // ends global timer
  
  double ElapsedSeconds   (std::string id);   // return elapsed time for specifc timer id
  double ElapsedGlobal    ();		      // return elapsed time since Init()
  double RawTimer         ();		      // raw timer

  void   Reset            ();	              // reset all timers
  void   Summarize        ();	              // pretty-print timing information
  int    SetSummarizeWidth(const int width);  // set max output width for summarize stdout

  size_t StatsCount       (std::string id);   // # of calls to timer (id)
  double StatsMean        (std::string id);   // mean time for timer (id)
  double StatsVariance    (std::string id);   //  variance for timer (id)

  // ------------------------------------------------------------------------
  // Historical timing support - note there are two primary mechanisms for
  // saving performance data: 
  // 
  // Mode 1: you are using the GRVY_Timer_Class to define individual
  //         sections to monitor and want to save the global runtime
  //         measurement and all individual subtimers
  // 
  // Mode 2: you are using other means to profile the application code
  //         and want to save a single global timing value. Routines
  //         for this mode are distinguished by the presence of an
  //         extra "timing" argument in the calling sequence.
  // 
  // In both modes, "short" and "long" calling sequences are supported
  // with the long version allowing additional optional runtime
  // documentation (e.g. flops, code revision) to be provided.
  // ------------------------------------------------------------------------

  // Mode 1: Saving internal GRVY timer values to historical repository

  int  SaveHistTiming      (std::string experiment, std::string comment, int num_procs, 
			    std::string filename);

  int  SaveHistTiming      (std::string experiment, std::string comment, int num_procs, 
			    int jobId, std::string code_revision, double flops, std::string filename);

  // Mode 2: Saving user-provided global timing to historical repository

  int  SaveHistTiming      (double timing, std::string machinename, std::string experiment, 
			    std::string comment, int num_procs, std::string filename);

  int  SaveHistTiming      (double timing, std::string machinename, std::string experiment, 
			    std::string comment, int num_procs, int jobId, std::string code_revision, 
			    double flops, std::string filename);

  // ---------------
  // Query Functions
  // ---------------

  void SummarizeHistTiming (std::string filename,   std::string delimiter, std::string outdir);

  // Class options 

  int  SetOption           (std::string option, bool flag);

private:
  class GRVY_Timer_ClassImp;	              // forward declaration to Timer implementation
  std::auto_ptr<GRVY_Timer_ClassImp> m_pimpl; // pointer to implementation

};

//--------------------------
// MPI Out-of-Core Class
//--------------------------

class GRVY_MPI_Ocore_Class {

public:
  GRVY_MPI_Ocore_Class(); 
 ~GRVY_MPI_Ocore_Class();

  int    Initialize   (std::string inputfile);
  void   Finalize     ();
  size_t NumActive    ();	// number of currently active records
  bool   isMaster     ();	// is the calling task the ocore master?
  bool   isEnabled    ();	// is MPI Ocore enabled? (can be controlled via input file)

  // Read/Write Functions

  template <typename T> int Write (size_t offset,T *data );
  template <typename T> int Read  (size_t offset,T *data );

  // Record retrieval/removal

  template <typename T> size_t PopRecord (T *data );

private:
  class GRVY_MPI_Ocore_ClassImp;		  // forward declaration to Ocore implementation
  std::auto_ptr<GRVY_MPI_Ocore_ClassImp> m_pimpl; // pointer to implementation
};

//--------------------
// HDF5 Utility Class
//--------------------

 class GRVY_HDF5_Class //: private boost::noncopyable
 {
   friend class GRVY_Timer_Class;

 public:
   GRVY_HDF5_Class  ();
  ~GRVY_HDF5_Class  ();

   GRVY_HDF5_Class  (const GRVY_HDF5_Class &rhs);
   GRVY_HDF5_Class  &operator= (GRVY_HDF5_Class );

   // File-related functions
   
   int  Create  (std::string filename, bool overwrite_existing);
   int  Open    (std::string filename, bool read_only         );
   bool Exists  (std::string filename);
   int  Close   ();

   // Group-related functions
   
   int  GroupCreate (std::string groupname);
   int  GroupOpen   (std::string groupname);
   bool GroupExists (std::string groupname);

   std::vector<std::string> ListSubGroups(std::string groupname);

   // Dataset-related functions

   int  DatasetOpen  (std::string groupname, std::string datasetname);
   bool DatasetExists(std::string groupname, std::string datasetname);

   // Attribute-related functions

   int  AttributeOpen  (std::string groupname, std::string attribute);
   bool AttributeExists(std::string groupname, std::string attribute);

   int AttributeWrite(std::string groupname, std::string attribute,          short int  value);
   int AttributeWrite(std::string groupname, std::string attribute,                int  value);
   int AttributeWrite(std::string groupname, std::string attribute,               long  value);
   int AttributeWrite(std::string groupname, std::string attribute, unsigned short int  value);
   int AttributeWrite(std::string groupname, std::string attribute,       unsigned int  value);
   int AttributeWrite(std::string groupname, std::string attribute,      unsigned long  value);
   int AttributeWrite(std::string groupname, std::string attribute,              float  value);
   int AttributeWrite(std::string groupname, std::string attribute,             double  value);
   int AttributeWrite(std::string groupname, std::string attribute,        std::string  value);

   int AttributeRead (std::string groupname, std::string attribute,          short int &value);
   int AttributeRead (std::string groupname, std::string attribute,                int &value);
   int AttributeRead (std::string groupname, std::string attribute,               long &value);
   int AttributeRead (std::string groupname, std::string attribute, unsigned short int &value);
   int AttributeRead (std::string groupname, std::string attribute,       unsigned int &value);
   int AttributeRead (std::string groupname, std::string attribute,      unsigned long &value);
   int AttributeRead (std::string groupname, std::string attribute,              float &value);
   int AttributeRead (std::string groupname, std::string attribute,             double &value);
   int AttributeRead (std::string groupname, std::string attribute,        std::string &value);

   // Dataset-related functions

   // Packet Table related functions
   
 private:
   //boost::scoped_ptr<GRVY_HDF5_ClassImp> m_pimpl;
   class GRVY_HDF5_ClassImp;	               // forward declaration of HDF5 implementation
   std::auto_ptr<GRVY_HDF5_ClassImp> m_pimpl;  // pointer to implementation
 };
}

#endif

#endif
